<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Remote Camera Viewer</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .main-video-container {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            position: relative;
            aspect-ratio: 4/3;
            max-height: 600px;
        }
        
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #111;
        }
        
        .video-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
        }
        
        .status-badge {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-connected { background: #00ff00; box-shadow: 0 0 8px #00ff00; }
        .status-connecting { background: #ffaa00; animation: pulse 1s infinite; }
        .status-disconnected { background: #ff0000; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .panel h3 {
            margin-bottom: 15px;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .camera-list {
            list-style: none;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .camera-item {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .camera-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }
        
        .camera-item.active {
            background: rgba(0,255,0,0.2);
            border: 1px solid #00ff00;
        }
        
        .camera-status {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 12px;
            background: rgba(0,0,0,0.3);
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        .log-container {
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .log-time {
            color: #888;
            margin-right: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-box {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #4facfe;
        }
        
        .stat-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        
        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìπ WebRTC Remote Camera Viewer</h1>
        
        <div class="main-video-container">
            <video id="remoteVideo" autoplay playsinline></video>
            <div class="video-overlay">
                <span id="connectionStatus" class="status-badge status-disconnected"></span>
                <span id="statusText">Disconnected</span>
            </div>
        </div>
        
        <div class="controls">
            <div class="panel">
                <h3>üîç Available Cameras</h3>
                <ul id="cameraList" class="camera-list">
                    <li class="empty-state">Waiting for cameras...</li>
                </ul>
                <button class="btn" onclick="refreshCameras()">üîÑ Refresh</button>
            </div>
            
            <div class="panel">
                <h3>‚öôÔ∏è Connection Control</h3>
                <div id="connectionControls">
                    <p style="margin-bottom: 15px; color: #aaa;">Select a camera from the list to connect</p>
                    <button class="btn btn-success" id="connectBtn" onclick="connectToCamera()" disabled>
                        üîå Connect
                    </button>
                    <button class="btn btn-danger" id="disconnectBtn" onclick="disconnect()" disabled>
                        ‚èπ Disconnect
                    </button>
                </div>
                
                <div class="stats-grid" id="statsPanel" style="display: none;">
                    <div class="stat-box">
                        <div class="stat-value" id="statResolution">-</div>
                        <div class="stat-label">Resolution</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statUptime">-</div>
                        <div class="stat-label">Uptime</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statFrames">-</div>
                        <div class="stat-label">Frames</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="statFps">-</div>
                        <div class="stat-label">FPS</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h3>üìù Event Log</h3>
            <div id="logContainer" class="log-container"></div>
            <button class="btn" onclick="clearLog()" style="margin-top: 10px;">Clear Log</button>
        </div>
    </div>

    <script>
        // Configuration
        const BROKER_URL = 'wss://e5122a5328ea4986a0295fa6e037655a.s2.eu.hivemq.cloud:8884/mqtt';
        const SIGNALING_TOPIC = 'webrtc/signaling';
        const ANNOUNCE_TOPIC = 'camera/announce';
        
        // State
        let mqttClient = null;
        let pc = null;
        let dc = null;
        let selectedCamera = null;
        let availableCameras = new Map();
        let connectionStartTime = null;
        let frameCount = 0;
        let lastFrameTime = Date.now();
        
        // Generate viewer ID
        const viewerId = 'viewer_' + Math.random().toString(36).substr(2, 6);
        
        // Logging
        function log(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
            console.log(`[${type}] ${message}`);
        }
        
        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
        }
        
        // Update connection status UI
        function updateStatus(status, text) {
            const badge = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            badge.className = 'status-badge';
            if (status === 'connected') badge.classList.add('status-connected');
            else if (status === 'connecting') badge.classList.add('status-connecting');
            else badge.classList.add('status-disconnected');
            
            statusText.textContent = text;
        }
        
        // Initialize MQTT
        function initMQTT() {
            log('Connecting to MQTT broker...');
            
            mqttClient = mqtt.connect(BROKER_URL, {
                rejectUnauthorized: false,
                clientId: viewerId,
                username: 'admin',
                password: 'admin1234S',
                protocol: 'wss'
            });
            
            mqttClient.on('connect', () => {
                log('‚úÖ Connected to MQTT broker');
                updateStatus('disconnected', 'Ready to connect');
                
                // Subscribe to topics
                mqttClient.subscribe([SIGNALING_TOPIC, ANNOUNCE_TOPIC], (err) => {
                    if (!err) {
                        log('üì° Subscribed to camera announcements');
                    }
                });
            });
            
            mqttClient.on('message', (topic, payload) => {
                try {
                    const msg = JSON.parse(payload.toString());
                    
                    if (topic === ANNOUNCE_TOPIC && msg.type === 'camera_available') {
                        handleCameraAnnouncement(msg);
                    } else if (topic === SIGNALING_TOPIC) {
                        handleSignalingMessage(msg);
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            });
            
            mqttClient.on('error', (err) => {
                log('‚ùå MQTT Error: ' + err.message, 'error');
            });
        }
        
        // Handle camera announcement
        function handleCameraAnnouncement(msg) {
            const cameraId = msg.camera_id;
            if (!availableCameras.has(cameraId)) {
                availableCameras.set(cameraId, {
                    id: cameraId,
                    lastSeen: Date.now()
                });
                log(`üìπ New camera available: ${cameraId}`);
                updateCameraList();
            } else {
                availableCameras.get(cameraId).lastSeen = Date.now();
            }
        }
        
        // Update camera list UI
        function updateCameraList() {
            const list = document.getElementById('cameraList');
            
            if (availableCameras.size === 0) {
                list.innerHTML = '<li class="empty-state">No cameras available</li>';
                return;
            }
            
            list.innerHTML = '';
            availableCameras.forEach((cam, id) => {
                const li = document.createElement('li');
                li.className = 'camera-item';
                if (selectedCamera === id) li.classList.add('active');
                
                const age = Math.floor((Date.now() - cam.lastSeen) / 1000);
                const status = age < 10 ? 'üü¢ Online' : 'üü° Away';
                
                li.innerHTML = `
                    <span>${id}</span>
                    <span class="camera-status">${status}</span>
                `;
                li.onclick = () => selectCamera(id);
                list.appendChild(li);
            });
        }
        
        // Select camera
        function selectCamera(cameraId) {
            selectedCamera = cameraId;
            updateCameraList();
            document.getElementById('connectBtn').disabled = false;
            log(`Selected camera: ${cameraId}`);
        }
        
        // Refresh camera list (remove stale cameras)
        function refreshCameras() {
            const now = Date.now();
            let removed = 0;
            for (const [id, cam] of availableCameras) {
                if (now - cam.lastSeen > 30000) { // Remove if not seen for 30s
                    availableCameras.delete(id);
                    removed++;
                }
            }
            if (removed > 0) {
                log(`Removed ${removed} stale camera(s)`);
                updateCameraList();
            }
        }
        
        // Handle WebRTC signaling
        async function handleSignalingMessage(msg) {
            if (msg.to !== viewerId) return;
            
            log(`üì• Received ${msg.type.toUpperCase()} from ${msg.from}`);
            
            switch (msg.type) {
                case 'offer':
                    await handleOffer(msg.data);
                    break;
                case 'ice':
                    await handleRemoteICE(msg.data);
                    break;
            }
        }
        
        // Connect to selected camera
        async function connectToCamera() {
            if (!selectedCamera) {
                alert('Please select a camera first');
                return;
            }
            
            updateStatus('connecting', 'Connecting...');
            log(`üîå Requesting connection to ${selectedCamera}...`);
            
            // Send view request
            const request = {
                type: 'view_request',
                from: viewerId,
                to: selectedCamera,
                data: {}
            };
            mqttClient.publish(SIGNALING_TOPIC, JSON.stringify(request));
        }
        
        // Handle offer from camera
        async function handleOffer(offerData) {
            log('üé• Processing camera offer...');
            
            // Create peer connection
            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            // Handle incoming tracks (video from camera)
            pc.ontrack = (event) => {
                log('üìπ Video track received!');
                const video = document.getElementById('remoteVideo');
                if (video.srcObject !== event.streams[0]) {
                    video.srcObject = event.streams[0];
                    connectionStartTime = Date.now();
                    updateStatus('connected', 'Live');
                    document.getElementById('statsPanel').style.display = 'grid';
                    startStatsUpdate();
                }
            };
            
            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignalingMessage('ice', event.candidate);
                }
            };
            
            pc.oniceconnectionstatechange = () => {
                log(`ICE State: ${pc.iceConnectionState}`);
                if (pc.iceConnectionState === 'connected') {
                    document.getElementById('disconnectBtn').disabled = false;
                    document.getElementById('connectBtn').disabled = true;
                } else if (pc.iceConnectionState === 'disconnected') {
                    disconnect();
                }
            };
            
            // Handle data channel (camera control)
            pc.ondatachannel = (event) => {
                dc = event.channel;
                setupDataChannel();
            };
            
            // Set remote description (offer)
            await pc.setRemoteDescription(new RTCSessionDescription(offerData));
            
            // Create answer
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            // Send answer
            sendSignalingMessage('answer', { sdp: answer.sdp, type: answer.type });
            log('‚úÖ Answer sent to camera');
        }
        
        // Setup data channel for camera control
        function setupDataChannel() {
            dc.onopen = () => {
                log('üì° Control channel opened');
                // Request camera info
                dc.send(JSON.stringify({ action: 'get_info' }));
            };
            
            dc.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'info') {
                        updateStats(msg.data);
                    }
                } catch (e) {
                    log(`üì© Camera: ${event.data}`);
                }
            };
            
            dc.onclose = () => {
                log('üì° Control channel closed');
            };
        }
        
        // Handle remote ICE candidate
        async function handleRemoteICE(candidateData) {
            try {
                await pc.addIceCandidate(new RTCIceCandidate(candidateData));
            } catch (e) {
                console.error('Error adding ICE candidate:', e);
            }
        }
        
        // Send signaling message
        function sendSignalingMessage(type, data) {
            const msg = {
                type: type,
                from: viewerId,
                to: selectedCamera,
                data: data
            };
            mqttClient.publish(SIGNALING_TOPIC, JSON.stringify(msg));
        }
        
        // Disconnect
        function disconnect() {
            if (dc) {
                dc.close();
                dc = null;
            }
            if (pc) {
                pc.close();
                pc = null;
            }
            
            document.getElementById('remoteVideo').srcObject = null;
            updateStatus('disconnected', 'Disconnected');
            document.getElementById('connectBtn').disabled = false;
            document.getElementById('disconnectBtn').disabled = true;
            document.getElementById('statsPanel').style.display = 'none';
            
            log('‚èπ Disconnected');
        }
        
        // Update statistics display
        function updateStats(data) {
            if (data.resolution) {
                document.getElementById('statResolution').textContent = data.resolution;
            }
            if (data.frames_sent) {
                document.getElementById('statFrames').textContent = data.frames_sent;
            }
        }
        
        // Start periodic stats update
        function startStatsUpdate() {
            setInterval(() => {
                if (connectionStartTime) {
                    const uptime = Math.floor((Date.now() - connectionStartTime) / 1000);
                    const mins = Math.floor(uptime / 60);
                    const secs = uptime % 60;
                    document.getElementById('statUptime').textContent = 
                        mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                }
                
                // Calculate FPS
                const now = Date.now();
                const video = document.getElementById('remoteVideo');
                if (video.readyState >= 2) {
                    // Get video stats if available
                    if (pc && pc.getStats) {
                        pc.getStats().then(stats => {
                            stats.forEach(report => {
                                if (report.type === 'inbound-rtp' && report.kind === 'video') {
                                    const fps = report.framesPerSecond || 0;
                                    document.getElementById('statFps').textContent = 
                                        Math.round(fps) + ' fps';
                                }
                            });
                        });
                    }
                }
            }, 1000);
        }
        
        // Cleanup old cameras periodically
        setInterval(refreshCameras, 10000);
        
        // Initialize
        window.onload = () => {
            log(`Viewer initialized: ${viewerId}`);
            initMQTT();
        };
        
        // Cleanup on page unload
        window.onbeforeunload = () => {
            disconnect();
            if (mqttClient) mqttClient.end();
        };
    </script>
</body>
</html>